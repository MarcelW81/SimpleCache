{"name":"SimpleCache","tagline":"Extension methods for System.Runtime.Caching.ObjectCache / MemoryCache with locking mechanism.","body":"# SimpleCache\r\n\r\n- Allows you to check if some value exists in cache and if not, acquire the value and put it in cache, using 1 method call.\r\n- Takes care of locking while the value is being acquired when it does not yet exist in cache.\r\n- Generates cachekeys including the type name being cached so you can use the same key (ie FindAll) for different types.\r\n\r\n[![Build status](http://img.shields.io/appveyor/ci/mwijnands/simplecache.svg?style=flat)](https://ci.appveyor.com/project/mwijnands/simplecache) [![NuGet version](http://img.shields.io/nuget/v/XperiCode.SimpleCache.svg?style=flat)](https://www.nuget.org/packages/XperiCode.SimpleCache)\r\n\r\n## Installation\r\n\r\nThe `SimpleCache` package is available at [NuGet](https://www.nuget.org/packages/XperiCode.SimpleCache). To install `SimpleCache`, run the following command in the [Package Manager Console](http://docs.nuget.org/docs/start-here/using-the-package-manager-console):\r\n\r\n> #### Install-Package XperiCode.SimpleCache\r\n\r\n## Examples\r\n\r\nGet a value from cache and if it does not exist in cache yet, acquire it and put it in cache:\r\n\r\n```csharp\r\nvar person = MemoryCache.Default.Get(\"Find\", () => _personRepository.Find());\r\n```\r\n\r\nSame as above but the value will stay in the cache for only 15 minutes:\r\n\r\n```csharp\r\nvar person = MemoryCache.Default.Get(\"Find\", TimeSpan.FromMinutes(15), () => \r\n{\r\n    return _personRepository.Find();\r\n});\r\n```\r\n\r\nThere are methods available to invalidate cache at an absolute expirationdate or when a certain file has changed as well. For all these methods there are `async` versions available in case the acquire method is `async`:\r\n\r\n```csharp\r\nvar person = await MemoryCache.Default.GetAsync(\"Find\", () => \r\n{\r\n    return _personRepository.FindAsync();\r\n});\r\n```\r\n\r\nIf the acquire method takes a long time to finish, the extension methods take care of locking (even the `async` versions) so the acquire method will not be called multiple times after the value is acquired. So if 10 visitors would visit a webpage with the following code at the same time, the `SomeLongRunningMethod` method and `_personRepository.Find()` call will only be called **once**:\r\n\r\n```csharp\r\nvar person = MemoryCache.Default.Get(\"Find\", () =>\r\n{\r\n    SomeLongRunningMethod();\r\n    return _personRepository.Find();\r\n});\r\n```\r\n\r\n## Collaboration\r\n\r\nPlease report issues if you find any. Pull requests are welcome!\r\n","google":"UA-58216824-2","note":"Don't delete this file! It's used internally to help with page regeneration."}